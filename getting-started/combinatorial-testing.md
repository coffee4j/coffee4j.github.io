---
layout: page
title: Combinatorial Test Input Generation
permalink: /getting-started/combinatorial-test-input/
---

* [Back to Overview](../)

Coffee4j models combinatorial tests via `Parameter` and `Value` classes.
Consider the following example parameters and values for testing an online browser game.
These parameter and values form an <i>input parameter model</i> (IPM), which is used as the running example in all following demonstrations.

OS      | Browser | Ping   | Speed    
--------|---------|--------|----------
Windows | Chrome  | 10ms   | 1 KB/s   
Linux   | Edge    | 100ms  | 10 KB/s  
MacOS   | Firefox | 1000ms | 100 KB/s
Android | Safari  |        | 1000 KB/s
iOS     |         |        |          


### Basic Example

A basic JUnit5 test for the above model could look as follows.

{% highlight java %}
class BasicExample {

  private static InputParameterModel model() {
    return inputParameterModel("game-model")
        .strength(2)
        .parameters(
            parameter("OS").values("Windows", "Linux", "MacOS", "Android", "iOS"),
            parameter("Browser").values("Chrome", "Edge", "Firefox", "Safari"),
            parameter("Ping").values(10, 100, 1000),
            parameter("Speed").values(1, 10, 100, 1000)
        ).build();
  }

  @CombinatorialTest
  @ModelFromMethod("model")
  void testGame(String os, String browser, int ping, int speed) {
    System.out.println("OS=" + os + ", Browser=" + browser + ", Ping=" + ping + ", Speed=" + speed);
  }
}

{% endhighlight %}

The first method defines the complete `InputParameterModel` including the desired testing strength and all parameters with their values.
The `testGame` method is written like a normal JUnit5 <i>parameterized test</i> with the difference only being the
annotations.
`@CombinatorialTest` marks the method as a combinatorial test method.
This means that JUnit will automatically call coffee4j to generate the inputs for the method.
The second annotation (`@ModelFromMethod("model")`) is used to define the source method which contains the input parameter model.
Once the test execution is started, coffee4j uses the IPOG combination strategy to generate test inputs covering all parameters in the given strength.
It will then call the `testGame` method for each generated test input.

### Testing Strength

Testing strength describes the <i>degree</i> to which the values of the input parameter model are combined.
For instance, a test suite which is generated with a testing strength of 1 (also called <i>each-choice</i>) contains each value at least once.
A testing strength of 2 (also called <i>pairwise</i>) results in a test suite that contains each pair of values at least once.
To achieve a higher testing strength, simply change the value in the `model` method form the example above.
The combinatorial test input generation algorithm automatically uses the value once the test is started.

### Constraints

Most models require the definition of some constraints to exclude irrelevant value combinations which shall not appear in the test suite.
For example, the test input `OS=Linux, Browser=Safari, Ping=10, Speed=10` could be generated by the algorithm.
However, the combination of `OS=Linux` and `Browser=Safari` is useless and thus irrelevant because there is no Safari implementation available for Linux.

To exclude the irrelevant combination, it is possible to add constraints to the model.

{% highlight java %}

private static InputParameterModel model() {
  return inputParameterModel("game-model")
      .strength(2)
      .parameters(
          parameter("OS").values("Windows", "Linux", "MacOS", "Android", "iOS"),
          parameter("Browser").values("Chrome", "Edge", "Firefox", "Safari"),
          parameter("Ping").values(10, 100, 1000),
          parameter("Speed").values(1, 10, 100, 1000))
      .exclusionConstraint(constrain("OS", "Browser")
          .by((String os, String browser) -> !(os.equals("Linux") && browser.equals("Safari")))
      ).build();
}

{% endhighlight %}

The lambda given to `by` can be an arbitrary function.
Thus, the constraint model of coffee4j offers maximum flexibility.
The <a href="/apidocs/de/rwth/swc/coffee4j/model/constraints/ConstraintBuilder.html">`ConstraintBuilder`</a> offers `constrain` functions for up to six parameter.
Since `exclusionConstraint` accepts an arbitrary <a href="/apidocs/de/rwth/swc/coffee4j/model/constraints/Constraint.html">`Constraint`</a>, constraints involving more than two parameters are also possible.

### Different Algorithms

Coffee4j's framework is extensible and supports many different algorithms for test input generation.
Therefore, the framework includes the `@Generator` annotation to select an algorithm as demonstrated below.

{% highlight java %}
class BasicExample {

  @CombinatorialTest
  @ModelFromMethod("model")
  @Generator(Ipog.class)
  void testGame(String os, String browser, int ping, int speed) {
    System.out.println("OS=" + os + ", Browser=" + browser + ", Ping=" + ping + ", Speed=" + speed);
  }
}

{% endhighlight %}

This explicitly tells the framework to use the IPOG generator.
Since IPOG is the default algorithm, it does not need to be registered explicitly.
In the case that another algorithm should be used, simple include the annotation and specify the algorithm `class`
(which needs to implement the <a href="/apidocs/de/rwth/swc/coffee4j/engine/generator/TestInputGroupGenerator.html">TestInputGroupGenerator</a> interface).

It is also possible to add multiple generation algorithms to one method by explicitly setting the `value` attribute
of the annotation:

{% highlight java %}

@Generator(value = {Ipog.class, IpogNeg.class})

{% endhighlight %}
